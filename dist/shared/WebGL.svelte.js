import './WebGL.svelte.css.proxy.js';
/* src/shared/WebGL.svelte generated by Svelte v3.38.3 */
import {
	SvelteComponent,
	attr,
	binding_callbacks,
	detach,
	element,
	globals,
	init,
	insert,
	listen,
	noop,
	safe_not_equal
} from "../../_snowpack/pkg/svelte/internal.js";

const { window: window_1 } = globals;
import { onMount } from "../../_snowpack/pkg/svelte.js";

function create_fragment(ctx) {
	let canvas_1;
	let mounted;
	let dispose;

	return {
		c() {
			canvas_1 = element("canvas");
			attr(canvas_1, "class", "WebGL svelte-6tls7n");
		},
		m(target, anchor) {
			insert(target, canvas_1, anchor);
			/*canvas_1_binding*/ ctx[3](canvas_1);

			if (!mounted) {
				dispose = listen(window_1, "resize", /*handleResize*/ ctx[1]);
				mounted = true;
			}
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(canvas_1);
			/*canvas_1_binding*/ ctx[3](null);
			mounted = false;
			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { shader_import } = $$props;
	let canvas;

	function handleResize() {
		$$invalidate(0, canvas.width = canvas.getBoundingClientRect().width, canvas);
		$$invalidate(0, canvas.height = canvas.getBoundingClientRect().height, canvas);
	}

	onMount(() => {
		$$invalidate(0, canvas.width = canvas.getBoundingClientRect().width, canvas);
		$$invalidate(0, canvas.height = canvas.getBoundingClientRect().height, canvas);

		const vertexShaderText = `
precision mediump float;

attribute vec2 vertPosition;

varying vec3 fragColor;

void main() {
    gl_Position = vec4(vertPosition, 0.0, 1.0);
}
        `;

		const fragmentShaderText = shader_import;
		var gl = canvas.getContext("webgl");

		if (!gl) {
			gl = canvas.getContext("experimental-webgl");
		}

		if (gl) {
			gl.clearColor(0.75, 0.85, 0.8, 1);
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
			var vertexShader = gl.createShader(gl.VERTEX_SHADER);
			var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
			gl.shaderSource(vertexShader, vertexShaderText);
			gl.shaderSource(fragmentShader, fragmentShaderText);
			gl.compileShader(vertexShader);

			if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
				console.error("ERROR compiling vertex shader!", gl.getShaderInfoLog(vertexShader));
				return;
			}

			gl.compileShader(fragmentShader);

			if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
				console.error("ERROR compiling fragment shader!", gl.getShaderInfoLog(fragmentShader));
				return;
			}

			var program = gl.createProgram();
			gl.attachShader(program, vertexShader);
			gl.attachShader(program, fragmentShader);
			gl.linkProgram(program);

			if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
				console.error("ERROR linking program", gl.getProgramInfoLog(program));
				return;
			}

			gl.validateProgram(program);

			if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {
				console.error("ERROR validating program", gl.getProgramInfoLog(program));
				return;
			}

			var triangleVertices = [
				//  X, Y
				-1,
				3,
				-1,
				-1,
				3,
				-1
			];

			var triangleVertexBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(triangleVertices), gl.STATIC_DRAW);
			var positionAttribLocation = gl.getAttribLocation(program, "vertPosition");
			gl.vertexAttribPointer(positionAttribLocation, 2, gl.FLOAT, gl.FALSE, 2 * Float32Array.BYTES_PER_ELEMENT, 0);
			gl.enableVertexAttribArray(positionAttribLocation);
			gl.useProgram(program);
			var timeLocation = gl.getUniformLocation(program, "u_time");
			var resLocation = gl.getUniformLocation(program, "u_resolution");
			var scrollLocation = gl.getUniformLocation(program, "u_scroll");

			function renderLoop(time) {
				gl.uniform1f(timeLocation, time);
				gl.uniform1f(scrollLocation, window.scrollY);
				gl.uniform2f(resLocation, canvas.getBoundingClientRect().width, canvas.getBoundingClientRect().height);
				gl.drawArrays(gl.TRIANGLES, 0, 3);
				requestAnimationFrame(renderLoop);
			}

			requestAnimationFrame(renderLoop);
		}
	});

	function canvas_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			canvas = $$value;
			$$invalidate(0, canvas);
		});
	}

	$$self.$$set = $$props => {
		if ("shader_import" in $$props) $$invalidate(2, shader_import = $$props.shader_import);
	};

	return [canvas, handleResize, shader_import, canvas_1_binding];
}

class WebGL extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { shader_import: 2 });
	}
}

export default WebGL;