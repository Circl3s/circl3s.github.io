import './Programming.svelte.css.proxy.js';
/* src/portfolio/Programming.svelte generated by Svelte v3.38.3 */
import {
	SvelteComponent,
	append,
	attr,
	create_component,
	destroy_component,
	detach,
	element,
	init,
	insert,
	mount_component,
	safe_not_equal,
	space,
	text,
	transition_in,
	transition_out
} from "../../_snowpack/pkg/svelte/internal.js";

import Button from "../shared/Button.svelte.js";
import Card from "../shared/Card.svelte.js";
import Footer from "../shared/Footer.svelte.js";
import Navbar from "../shared/Navbar.svelte.js";
import Portfolio from "./Portfolio.svelte.js";
import Section from "../shared/Section.svelte.js";
import TechInfo from "../shared/TechInfo.svelte.js";

function create_default_slot_12(ctx) {
	let t;

	return {
		c() {
			t = text("Visit my Github");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (134:4) <Section>
function create_default_slot_11(ctx) {
	let h1;
	let t1;
	let div1;
	let div0;
	let p;
	let t4;
	let button;
	let current;

	button = new Button({
			props: {
				href: "https://github.com/Circl3s/",
				$$slots: { default: [create_default_slot_12] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			h1 = element("h1");
			h1.textContent = "Programming";
			t1 = space();
			div1 = element("div");
			div0 = element("div");
			p = element("p");

			p.innerHTML = `I love programming. Here are some of the projects I made.<br/>
                    (This section will be expanded)`;

			t4 = space();
			create_component(button.$$.fragment);
			attr(h1, "class", "svelte-1apqkne");
			attr(div0, "class", "col svelte-1apqkne");
			attr(div1, "class", "content svelte-1apqkne");
		},
		m(target, anchor) {
			insert(target, h1, anchor);
			insert(target, t1, anchor);
			insert(target, div1, anchor);
			append(div1, div0);
			append(div0, p);
			append(div0, t4);
			mount_component(button, div0, null);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 1) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(h1);
			if (detaching) detach(t1);
			if (detaching) detach(div1);
			destroy_component(button);
		}
	};
}

// (151:16) 
function create_title_slot_6(ctx) {
	let h2;

	return {
		c() {
			h2 = element("h2");
			h2.textContent = "circl3s.github.io";
			attr(h2, "slot", "title");
		},
		m(target, anchor) {
			insert(target, h2, anchor);
		},
		d(detaching) {
			if (detaching) detach(h2);
		}
	};
}

// (164:28) 
function create_header_slot_15(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			attr(img, "class", "logo svelte-1apqkne");
			if (img.src !== (img_src_value = "/img/svelte-logotype.png")) attr(img, "src", img_src_value);
			attr(img, "alt", "Svelte");
			attr(img, "slot", "header");
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (165:28) 
function create_content_slot_22(ctx) {
	let p;

	return {
		c() {
			p = element("p");
			p.textContent = "The website is made out of custom reusable and responsive components built with Svelte.";
			attr(p, "slot", "content");
		},
		m(target, anchor) {
			insert(target, p, anchor);
		},
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (170:28) 
function create_header_slot_14(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			div.innerHTML = `<img class="logo svelte-1apqkne" src="/img/snowpack.svg" alt="Snowpack Logo"/>Snowpack`;
			attr(div, "class", "logotype text-2xl svelte-1apqkne");
			attr(div, "slot", "header");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (171:28) 
function create_content_slot_21(ctx) {
	let p;

	return {
		c() {
			p = element("p");
			p.textContent = "I chose Snowpack as the build tool because of its simplicity and speed.";
			attr(p, "slot", "content");
		},
		m(target, anchor) {
			insert(target, p, anchor);
		},
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (176:28) 
function create_header_slot_13(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			attr(img, "class", "logo svelte-1apqkne");
			if (img.src !== (img_src_value = "/img/tailwindcss-logotype.svg")) attr(img, "src", img_src_value);
			attr(img, "alt", "TailwindCSS");
			attr(img, "slot", "header");
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (177:28) 
function create_content_slot_20(ctx) {
	let p;

	return {
		c() {
			p = element("p");
			p.textContent = "TailwindCSS is used to style the website. It allowed me to maintain creative freedom and minimal stylesheet size while keeping the styles standardized.";
			attr(p, "slot", "content");
		},
		m(target, anchor) {
			insert(target, p, anchor);
		},
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (182:28) 
function create_header_slot_12(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			attr(img, "class", "logo svelte-1apqkne");
			if (img.src !== (img_src_value = "/img/supabase-logo-wordmark--dark.svg")) attr(img, "src", img_src_value);
			attr(img, "alt", "Supabase");
			attr(img, "slot", "header");
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (183:28) 
function create_content_slot_19(ctx) {
	let p;

	return {
		c() {
			p = element("p");
			p.textContent = "Supabase is used to run the \"News\" microblog on this site. As an open source alternative to Firebase, it's a great tool for small projects.";
			attr(p, "slot", "content");
		},
		m(target, anchor) {
			insert(target, p, anchor);
		},
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (188:20) <Button href="https://github.com/Circl3s/circl3s.github.io/">
function create_default_slot_10(ctx) {
	let t;

	return {
		c() {
			t = text("View source code");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (152:16) 
function create_content_slot_18(ctx) {
	let div1;
	let p0;
	let t4;
	let p1;
	let t6;
	let div0;
	let techinfo0;
	let t7;
	let techinfo1;
	let t8;
	let techinfo2;
	let t9;
	let techinfo3;
	let t10;
	let button;
	let current;

	techinfo0 = new TechInfo({
			props: {
				bg_color: "#F73C00",
				text_color: "white",
				$$slots: {
					content: [create_content_slot_22],
					header: [create_header_slot_15]
				},
				$$scope: { ctx }
			}
		});

	techinfo1 = new TechInfo({
			props: {
				bg_color: "#2E5E82",
				text_color: "white",
				$$slots: {
					content: [create_content_slot_21],
					header: [create_header_slot_14]
				},
				$$scope: { ctx }
			}
		});

	techinfo2 = new TechInfo({
			props: {
				bg_color: "#FFFFFF",
				text_color: "black",
				$$slots: {
					content: [create_content_slot_20],
					header: [create_header_slot_13]
				},
				$$scope: { ctx }
			}
		});

	techinfo3 = new TechInfo({
			props: {
				bg_color: "#1E1E1E",
				text_color: "white",
				$$slots: {
					content: [create_content_slot_19],
					header: [create_header_slot_12]
				},
				$$scope: { ctx }
			}
		});

	button = new Button({
			props: {
				href: "https://github.com/Circl3s/circl3s.github.io/",
				$$slots: { default: [create_default_slot_10] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div1 = element("div");
			p0 = element("p");

			p0.innerHTML = `Access: <code class="text-green-500">Public</code><br/>
                        Development: <code class="text-green-500">Active</code>`;

			t4 = space();
			p1 = element("p");
			p1.textContent = "That's this site. \n                        I kinda overengineered it on purpose so there's a lot of technologies and frameworks at play here. \n                        The important part is that it's not a template, it's been built and styled from the ground up by me.";
			t6 = space();
			div0 = element("div");
			create_component(techinfo0.$$.fragment);
			t7 = space();
			create_component(techinfo1.$$.fragment);
			t8 = space();
			create_component(techinfo2.$$.fragment);
			t9 = space();
			create_component(techinfo3.$$.fragment);
			t10 = space();
			create_component(button.$$.fragment);
			attr(p0, "class", "status svelte-1apqkne");
			attr(div0, "class", "techstack svelte-1apqkne");
			attr(div1, "class", "description");
			attr(div1, "slot", "content");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, p0);
			append(div1, t4);
			append(div1, p1);
			append(div1, t6);
			append(div1, div0);
			mount_component(techinfo0, div0, null);
			append(div0, t7);
			mount_component(techinfo1, div0, null);
			append(div0, t8);
			mount_component(techinfo2, div0, null);
			append(div0, t9);
			mount_component(techinfo3, div0, null);
			append(div1, t10);
			mount_component(button, div1, null);
			current = true;
		},
		p(ctx, dirty) {
			const techinfo0_changes = {};

			if (dirty & /*$$scope*/ 1) {
				techinfo0_changes.$$scope = { dirty, ctx };
			}

			techinfo0.$set(techinfo0_changes);
			const techinfo1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				techinfo1_changes.$$scope = { dirty, ctx };
			}

			techinfo1.$set(techinfo1_changes);
			const techinfo2_changes = {};

			if (dirty & /*$$scope*/ 1) {
				techinfo2_changes.$$scope = { dirty, ctx };
			}

			techinfo2.$set(techinfo2_changes);
			const techinfo3_changes = {};

			if (dirty & /*$$scope*/ 1) {
				techinfo3_changes.$$scope = { dirty, ctx };
			}

			techinfo3.$set(techinfo3_changes);
			const button_changes = {};

			if (dirty & /*$$scope*/ 1) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(techinfo0.$$.fragment, local);
			transition_in(techinfo1.$$.fragment, local);
			transition_in(techinfo2.$$.fragment, local);
			transition_in(techinfo3.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(techinfo0.$$.fragment, local);
			transition_out(techinfo1.$$.fragment, local);
			transition_out(techinfo2.$$.fragment, local);
			transition_out(techinfo3.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_component(techinfo0);
			destroy_component(techinfo1);
			destroy_component(techinfo2);
			destroy_component(techinfo3);
			destroy_component(button);
		}
	};
}

// (199:16) 
function create_title_slot_5(ctx) {
	let h2;

	return {
		c() {
			h2 = element("h2");
			h2.textContent = "Cybertracks";
			attr(h2, "slot", "title");
		},
		m(target, anchor) {
			insert(target, h2, anchor);
		},
		d(detaching) {
			if (detaching) detach(h2);
		}
	};
}

// (211:28) 
function create_header_slot_11(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			attr(img, "class", "logo svelte-1apqkne");
			if (img.src !== (img_src_value = "/img/React.png")) attr(img, "src", img_src_value);
			attr(img, "alt", "React");
			attr(img, "slot", "header");
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (212:28) 
function create_content_slot_17(ctx) {
	let p;

	return {
		c() {
			p = element("p");
			p.textContent = "The one-page UI is built with custom React components.";
			attr(p, "slot", "content");
		},
		m(target, anchor) {
			insert(target, p, anchor);
		},
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (217:28) 
function create_header_slot_10(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			attr(img, "class", "logo svelte-1apqkne");
			if (img.src !== (img_src_value = "/img/tailwindcss-logotype.svg")) attr(img, "src", img_src_value);
			attr(img, "alt", "TailwindCSS");
			attr(img, "slot", "header");
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (218:28) 
function create_content_slot_16(ctx) {
	let p;

	return {
		c() {
			p = element("p");
			p.textContent = "TailwindCSS is used to style the website. It allowed me to maintain creative freedom and minimal stylesheet size while keeping the styles standardized.";
			attr(p, "slot", "content");
		},
		m(target, anchor) {
			insert(target, p, anchor);
		},
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (223:28) 
function create_header_slot_9(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			attr(img, "class", "logo svelte-1apqkne");
			if (img.src !== (img_src_value = "/img/Tonejs.png")) attr(img, "src", img_src_value);
			attr(img, "alt", "TailwindCSS");
			attr(img, "slot", "header");
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (224:28) 
function create_content_slot_15(ctx) {
	let p;

	return {
		c() {
			p = element("p");
			p.textContent = "All audio is sequenced, generated and processed by the Web Audio API through the use of Tone.js.";
			attr(p, "slot", "content");
		},
		m(target, anchor) {
			insert(target, p, anchor);
		},
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (230:24) <Button href="https://circl3s.github.io/cybertracks" color="green">
function create_default_slot_9(ctx) {
	let t;

	return {
		c() {
			t = text("Open app");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (233:24) <Button href="https://github.com/Circl3s/cybertracks">
function create_default_slot_8(ctx) {
	let t;

	return {
		c() {
			t = text("View source code");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (200:16) 
function create_content_slot_14(ctx) {
	let div2;
	let p0;
	let t4;
	let p1;
	let t6;
	let div0;
	let techinfo0;
	let t7;
	let techinfo1;
	let t8;
	let techinfo2;
	let t9;
	let div1;
	let button0;
	let t10;
	let button1;
	let current;

	techinfo0 = new TechInfo({
			props: {
				bg_color: "#282C34",
				text_color: "white",
				$$slots: {
					content: [create_content_slot_17],
					header: [create_header_slot_11]
				},
				$$scope: { ctx }
			}
		});

	techinfo1 = new TechInfo({
			props: {
				bg_color: "#FFFFFF",
				text_color: "black",
				$$slots: {
					content: [create_content_slot_16],
					header: [create_header_slot_10]
				},
				$$scope: { ctx }
			}
		});

	techinfo2 = new TechInfo({
			props: {
				bg_color: "#000000",
				text_color: "white",
				$$slots: {
					content: [create_content_slot_15],
					header: [create_header_slot_9]
				},
				$$scope: { ctx }
			}
		});

	button0 = new Button({
			props: {
				href: "https://circl3s.github.io/cybertracks",
				color: "green",
				$$slots: { default: [create_default_slot_9] },
				$$scope: { ctx }
			}
		});

	button1 = new Button({
			props: {
				href: "https://github.com/Circl3s/cybertracks",
				$$slots: { default: [create_default_slot_8] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div2 = element("div");
			p0 = element("p");

			p0.innerHTML = `Access: <code class="text-green-500">Public</code><br/>
                        Development: <code class="text-green-500">Active</code>`;

			t4 = space();
			p1 = element("p");
			p1.textContent = "A tracker-style music creation tool for the web. \n                        I wanted to honor the long-forgotten great-grandfathers of Digital Audio Workstations by implementing their unique workflow on a website.";
			t6 = space();
			div0 = element("div");
			create_component(techinfo0.$$.fragment);
			t7 = space();
			create_component(techinfo1.$$.fragment);
			t8 = space();
			create_component(techinfo2.$$.fragment);
			t9 = space();
			div1 = element("div");
			create_component(button0.$$.fragment);
			t10 = space();
			create_component(button1.$$.fragment);
			attr(p0, "class", "status svelte-1apqkne");
			attr(div0, "class", "techstack svelte-1apqkne");
			attr(div1, "class", "actions svelte-1apqkne");
			attr(div2, "class", "description");
			attr(div2, "slot", "content");
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, p0);
			append(div2, t4);
			append(div2, p1);
			append(div2, t6);
			append(div2, div0);
			mount_component(techinfo0, div0, null);
			append(div0, t7);
			mount_component(techinfo1, div0, null);
			append(div0, t8);
			mount_component(techinfo2, div0, null);
			append(div2, t9);
			append(div2, div1);
			mount_component(button0, div1, null);
			append(div1, t10);
			mount_component(button1, div1, null);
			current = true;
		},
		p(ctx, dirty) {
			const techinfo0_changes = {};

			if (dirty & /*$$scope*/ 1) {
				techinfo0_changes.$$scope = { dirty, ctx };
			}

			techinfo0.$set(techinfo0_changes);
			const techinfo1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				techinfo1_changes.$$scope = { dirty, ctx };
			}

			techinfo1.$set(techinfo1_changes);
			const techinfo2_changes = {};

			if (dirty & /*$$scope*/ 1) {
				techinfo2_changes.$$scope = { dirty, ctx };
			}

			techinfo2.$set(techinfo2_changes);
			const button0_changes = {};

			if (dirty & /*$$scope*/ 1) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(techinfo0.$$.fragment, local);
			transition_in(techinfo1.$$.fragment, local);
			transition_in(techinfo2.$$.fragment, local);
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(techinfo0.$$.fragment, local);
			transition_out(techinfo1.$$.fragment, local);
			transition_out(techinfo2.$$.fragment, local);
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div2);
			destroy_component(techinfo0);
			destroy_component(techinfo1);
			destroy_component(techinfo2);
			destroy_component(button0);
			destroy_component(button1);
		}
	};
}

// (245:16) 
function create_title_slot_4(ctx) {
	let h2;

	return {
		c() {
			h2 = element("h2");
			h2.textContent = "Neko Launcher";
			attr(h2, "slot", "title");
		},
		m(target, anchor) {
			insert(target, h2, anchor);
		},
		d(detaching) {
			if (detaching) detach(h2);
		}
	};
}

// (257:28) 
function create_header_slot_8(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			if (img.src !== (img_src_value = "/img/Flutter.svg")) attr(img, "src", img_src_value);
			attr(img, "alt", "Flutter");
			attr(img, "class", "logo svelte-1apqkne");
			attr(img, "slot", "header");
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (258:28) 
function create_content_slot_13(ctx) {
	let p;

	return {
		c() {
			p = element("p");
			p.textContent = "The desktop app is built with the Flutter framework using Material widgets.";
			attr(p, "slot", "content");
		},
		m(target, anchor) {
			insert(target, p, anchor);
		},
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (263:28) 
function create_header_slot_7(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			attr(img, "class", "logo svelte-1apqkne");
			if (img.src !== (img_src_value = "/img/supabase-logo-wordmark--dark.svg")) attr(img, "src", img_src_value);
			attr(img, "alt", "Supabase");
			attr(img, "slot", "header");
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (264:28) 
function create_content_slot_12(ctx) {
	let p;

	return {
		c() {
			p = element("p");
			p.textContent = "Using the launcher you can register and login, customize your profile and socialize with other users. Supabase is the all-in-one backend handling this.";
			attr(p, "slot", "content");
		},
		m(target, anchor) {
			insert(target, p, anchor);
		},
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (270:24) <Button href="https://github.com/Neko-Services/neko_launcher_neo/releases" color="green">
function create_default_slot_7(ctx) {
	let t;

	return {
		c() {
			t = text("Download");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (273:24) <Button href="https://github.com/Neko-Services/neko_launcher_neo">
function create_default_slot_6(ctx) {
	let t;

	return {
		c() {
			t = text("View source code");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (246:16) 
function create_content_slot_11(ctx) {
	let div2;
	let p0;
	let t4;
	let p1;
	let t6;
	let div0;
	let techinfo0;
	let t7;
	let techinfo1;
	let t8;
	let div1;
	let button0;
	let t9;
	let button1;
	let current;

	techinfo0 = new TechInfo({
			props: {
				bg_color: "#042B59",
				text_color: "white",
				$$slots: {
					content: [create_content_slot_13],
					header: [create_header_slot_8]
				},
				$$scope: { ctx }
			}
		});

	techinfo1 = new TechInfo({
			props: {
				bg_color: "#1E1E1E",
				text_color: "white",
				$$slots: {
					content: [create_content_slot_12],
					header: [create_header_slot_7]
				},
				$$scope: { ctx }
			}
		});

	button0 = new Button({
			props: {
				href: "https://github.com/Neko-Services/neko_launcher_neo/releases",
				color: "green",
				$$slots: { default: [create_default_slot_7] },
				$$scope: { ctx }
			}
		});

	button1 = new Button({
			props: {
				href: "https://github.com/Neko-Services/neko_launcher_neo",
				$$slots: { default: [create_default_slot_6] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div2 = element("div");
			p0 = element("p");

			p0.innerHTML = `Access: <code class="text-green-500">Public</code><br/>
                        Development: <code class="text-green-500">Active</code>`;

			t4 = space();
			p1 = element("p");
			p1.textContent = "A game launcher focused on, but not limited to anime-style visual novels. \n                        Allows players to track their play time, categorize their games collection and even socialize, while being customizable.";
			t6 = space();
			div0 = element("div");
			create_component(techinfo0.$$.fragment);
			t7 = space();
			create_component(techinfo1.$$.fragment);
			t8 = space();
			div1 = element("div");
			create_component(button0.$$.fragment);
			t9 = space();
			create_component(button1.$$.fragment);
			attr(p0, "class", "status svelte-1apqkne");
			attr(div0, "class", "techstack svelte-1apqkne");
			attr(div1, "class", "actions svelte-1apqkne");
			attr(div2, "class", "description");
			attr(div2, "slot", "content");
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, p0);
			append(div2, t4);
			append(div2, p1);
			append(div2, t6);
			append(div2, div0);
			mount_component(techinfo0, div0, null);
			append(div0, t7);
			mount_component(techinfo1, div0, null);
			append(div2, t8);
			append(div2, div1);
			mount_component(button0, div1, null);
			append(div1, t9);
			mount_component(button1, div1, null);
			current = true;
		},
		p(ctx, dirty) {
			const techinfo0_changes = {};

			if (dirty & /*$$scope*/ 1) {
				techinfo0_changes.$$scope = { dirty, ctx };
			}

			techinfo0.$set(techinfo0_changes);
			const techinfo1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				techinfo1_changes.$$scope = { dirty, ctx };
			}

			techinfo1.$set(techinfo1_changes);
			const button0_changes = {};

			if (dirty & /*$$scope*/ 1) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(techinfo0.$$.fragment, local);
			transition_in(techinfo1.$$.fragment, local);
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(techinfo0.$$.fragment, local);
			transition_out(techinfo1.$$.fragment, local);
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div2);
			destroy_component(techinfo0);
			destroy_component(techinfo1);
			destroy_component(button0);
			destroy_component(button1);
		}
	};
}

// (285:16) 
function create_title_slot_3(ctx) {
	let h2;

	return {
		c() {
			h2 = element("h2");
			h2.textContent = "Vetch";
			attr(h2, "slot", "title");
		},
		m(target, anchor) {
			insert(target, h2, anchor);
		},
		d(detaching) {
			if (detaching) detach(h2);
		}
	};
}

// (297:28) 
function create_header_slot_6(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			attr(img, "class", "logo svelte-1apqkne");
			if (img.src !== (img_src_value = "/img/v-logo.png")) attr(img, "src", img_src_value);
			attr(img, "alt", "V");
			attr(img, "slot", "header");
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (298:28) 
function create_content_slot_10(ctx) {
	let p;

	return {
		c() {
			p = element("p");
			p.textContent = "Vetch is written in V, a new, fast and safe language inspired by Go which produces small executables in record time.";
			attr(p, "slot", "content");
		},
		m(target, anchor) {
			insert(target, p, anchor);
		},
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (303:28) 
function create_header_slot_5(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			div.innerHTML = `<img class="logo svelte-1apqkne" src="/img/PowerShell.png" alt="PowerShell Logo"/>PowerShell`;
			attr(div, "class", "logotype text-2xl svelte-1apqkne");
			attr(div, "slot", "header");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (304:28) 
function create_content_slot_9(ctx) {
	let p;

	return {
		c() {
			p = element("p");
			p.textContent = "On Windows Vetch uses some PowerShell magic to fetch system info somewhat efficiently.";
			attr(p, "slot", "content");
		},
		m(target, anchor) {
			insert(target, p, anchor);
		},
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (309:28) 
function create_header_slot_4(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			div.textContent = "*nix";
			attr(div, "class", "logotype text-2xl svelte-1apqkne");
			attr(div, "slot", "header");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (310:28) 
function create_content_slot_8(ctx) {
	let p;

	return {
		c() {
			p = element("p");
			p.textContent = "On Unix-like operating systems Vetch uses standard Unix tools and tricks to fetch system info almost instantaneously.";
			attr(p, "slot", "content");
		},
		m(target, anchor) {
			insert(target, p, anchor);
		},
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (316:24) <Button disabled>
function create_default_slot_5(ctx) {
	let t;

	return {
		c() {
			t = text("Download (coming soon)");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (319:24) <Button href="https://github.com/Circl3s/vetch">
function create_default_slot_4(ctx) {
	let t;

	return {
		c() {
			t = text("View source code");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (286:16) 
function create_content_slot_7(ctx) {
	let div2;
	let p0;
	let t4;
	let p1;
	let t6;
	let div0;
	let techinfo0;
	let t7;
	let techinfo1;
	let t8;
	let techinfo2;
	let t9;
	let div1;
	let button0;
	let t10;
	let button1;
	let current;

	techinfo0 = new TechInfo({
			props: {
				bg_color: "#334",
				text_color: "#C9C5C4",
				$$slots: {
					content: [create_content_slot_10],
					header: [create_header_slot_6]
				},
				$$scope: { ctx }
			}
		});

	techinfo1 = new TechInfo({
			props: {
				bg_color: "#004880",
				text_color: "white",
				$$slots: {
					content: [create_content_slot_9],
					header: [create_header_slot_5]
				},
				$$scope: { ctx }
			}
		});

	techinfo2 = new TechInfo({
			props: {
				bg_color: "#F0EDE3",
				text_color: "#33290A",
				$$slots: {
					content: [create_content_slot_8],
					header: [create_header_slot_4]
				},
				$$scope: { ctx }
			}
		});

	button0 = new Button({
			props: {
				disabled: true,
				$$slots: { default: [create_default_slot_5] },
				$$scope: { ctx }
			}
		});

	button1 = new Button({
			props: {
				href: "https://github.com/Circl3s/vetch",
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div2 = element("div");
			p0 = element("p");

			p0.innerHTML = `Access: <code class="text-green-500">Public</code><br/>
                        Development: <code class="text-green-500">Active</code>`;

			t4 = space();
			p1 = element("p");
			p1.textContent = "Vetch is a simple, crossplatform system fetch program written in V.\n                        I was tired of all popular system fetches being only on Linux, so I made my own crossplatform one. And it's decently fast too!";
			t6 = space();
			div0 = element("div");
			create_component(techinfo0.$$.fragment);
			t7 = space();
			create_component(techinfo1.$$.fragment);
			t8 = space();
			create_component(techinfo2.$$.fragment);
			t9 = space();
			div1 = element("div");
			create_component(button0.$$.fragment);
			t10 = space();
			create_component(button1.$$.fragment);
			attr(p0, "class", "status svelte-1apqkne");
			attr(div0, "class", "techstack svelte-1apqkne");
			attr(div1, "class", "actions svelte-1apqkne");
			attr(div2, "class", "description");
			attr(div2, "slot", "content");
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, p0);
			append(div2, t4);
			append(div2, p1);
			append(div2, t6);
			append(div2, div0);
			mount_component(techinfo0, div0, null);
			append(div0, t7);
			mount_component(techinfo1, div0, null);
			append(div0, t8);
			mount_component(techinfo2, div0, null);
			append(div2, t9);
			append(div2, div1);
			mount_component(button0, div1, null);
			append(div1, t10);
			mount_component(button1, div1, null);
			current = true;
		},
		p(ctx, dirty) {
			const techinfo0_changes = {};

			if (dirty & /*$$scope*/ 1) {
				techinfo0_changes.$$scope = { dirty, ctx };
			}

			techinfo0.$set(techinfo0_changes);
			const techinfo1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				techinfo1_changes.$$scope = { dirty, ctx };
			}

			techinfo1.$set(techinfo1_changes);
			const techinfo2_changes = {};

			if (dirty & /*$$scope*/ 1) {
				techinfo2_changes.$$scope = { dirty, ctx };
			}

			techinfo2.$set(techinfo2_changes);
			const button0_changes = {};

			if (dirty & /*$$scope*/ 1) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(techinfo0.$$.fragment, local);
			transition_in(techinfo1.$$.fragment, local);
			transition_in(techinfo2.$$.fragment, local);
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(techinfo0.$$.fragment, local);
			transition_out(techinfo1.$$.fragment, local);
			transition_out(techinfo2.$$.fragment, local);
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div2);
			destroy_component(techinfo0);
			destroy_component(techinfo1);
			destroy_component(techinfo2);
			destroy_component(button0);
			destroy_component(button1);
		}
	};
}

// (331:16) 
function create_title_slot_2(ctx) {
	let h2;

	return {
		c() {
			h2 = element("h2");
			h2.textContent = "LoveShell";
			attr(h2, "slot", "title");
		},
		m(target, anchor) {
			insert(target, h2, anchor);
		},
		d(detaching) {
			if (detaching) detach(h2);
		}
	};
}

// (343:28) 
function create_header_slot_3(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			attr(img, "class", "logo svelte-1apqkne");
			if (img.src !== (img_src_value = "/img/crystal_logo.svg")) attr(img, "src", img_src_value);
			attr(img, "alt", "Crystal");
			attr(img, "slot", "header");
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (344:28) 
function create_content_slot_6(ctx) {
	let p;

	return {
		c() {
			p = element("p");
			p.textContent = "LoveShell is written in Crystal, a new blazing fast and type-safe programming language inspired by Ruby, which I really like.";
			attr(p, "slot", "content");
		},
		m(target, anchor) {
			insert(target, p, anchor);
		},
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (349:28) 
function create_header_slot_2(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			attr(img, "class", "logo svelte-1apqkne");
			if (img.src !== (img_src_value = "/img/BASH_logo-transparent-bg-color.svg")) attr(img, "src", img_src_value);
			attr(img, "alt", "Bash");
			attr(img, "slot", "header");
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (350:28) 
function create_content_slot_5(ctx) {
	let p;

	return {
		c() {
			p = element("p");
			p.textContent = "LoveShell still uses Bash under the hood as to not reinvent the wheel when it comes to scripting and environment variables.";
			attr(p, "slot", "content");
		},
		m(target, anchor) {
			insert(target, p, anchor);
		},
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (355:20) <Button href="https://github.com/I-love-os/LoveShell">
function create_default_slot_3(ctx) {
	let t;

	return {
		c() {
			t = text("View source code");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (332:16) 
function create_content_slot_4(ctx) {
	let div1;
	let p0;
	let t4;
	let p1;
	let t6;
	let div0;
	let techinfo0;
	let t7;
	let techinfo1;
	let t8;
	let button;
	let current;

	techinfo0 = new TechInfo({
			props: {
				bg_color: "#FFFFFF",
				text_color: "#000000",
				$$slots: {
					content: [create_content_slot_6],
					header: [create_header_slot_3]
				},
				$$scope: { ctx }
			}
		});

	techinfo1 = new TechInfo({
			props: {
				bg_color: "#FFFFFF",
				text_color: "#2F3A3E",
				$$slots: {
					content: [create_content_slot_5],
					header: [create_header_slot_2]
				},
				$$scope: { ctx }
			}
		});

	button = new Button({
			props: {
				href: "https://github.com/I-love-os/LoveShell",
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div1 = element("div");
			p0 = element("p");

			p0.innerHTML = `Access: <code class="text-yellow-500">Source Only</code><br/>
                        Development: <code class="text-red-500">Stopped</code>`;

			t4 = space();
			p1 = element("p");
			p1.textContent = "LoveShell is a fast and customizable Linux shell I made with my friends. \n                        The main idea was to make a shell that is easy to use and configure to beginners and nice looking out of the box.";
			t6 = space();
			div0 = element("div");
			create_component(techinfo0.$$.fragment);
			t7 = space();
			create_component(techinfo1.$$.fragment);
			t8 = space();
			create_component(button.$$.fragment);
			attr(p0, "class", "status svelte-1apqkne");
			attr(div0, "class", "techstack svelte-1apqkne");
			attr(div1, "class", "description");
			attr(div1, "slot", "content");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, p0);
			append(div1, t4);
			append(div1, p1);
			append(div1, t6);
			append(div1, div0);
			mount_component(techinfo0, div0, null);
			append(div0, t7);
			mount_component(techinfo1, div0, null);
			append(div1, t8);
			mount_component(button, div1, null);
			current = true;
		},
		p(ctx, dirty) {
			const techinfo0_changes = {};

			if (dirty & /*$$scope*/ 1) {
				techinfo0_changes.$$scope = { dirty, ctx };
			}

			techinfo0.$set(techinfo0_changes);
			const techinfo1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				techinfo1_changes.$$scope = { dirty, ctx };
			}

			techinfo1.$set(techinfo1_changes);
			const button_changes = {};

			if (dirty & /*$$scope*/ 1) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(techinfo0.$$.fragment, local);
			transition_in(techinfo1.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(techinfo0.$$.fragment, local);
			transition_out(techinfo1.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_component(techinfo0);
			destroy_component(techinfo1);
			destroy_component(button);
		}
	};
}

// (362:16) 
function create_title_slot_1(ctx) {
	let h2;

	return {
		c() {
			h2 = element("h2");
			h2.textContent = "Circl3s' Super Breakout";
			attr(h2, "slot", "title");
		},
		m(target, anchor) {
			insert(target, h2, anchor);
		},
		d(detaching) {
			if (detaching) detach(h2);
		}
	};
}

// (373:28) 
function create_header_slot_1(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			attr(img, "class", "logo svelte-1apqkne");
			if (img.src !== (img_src_value = "/img/PICO-8_logo.png")) attr(img, "src", img_src_value);
			attr(img, "alt", "PICO-8");
			attr(img, "slot", "header");
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (374:28) 
function create_content_slot_3(ctx) {
	let p;

	return {
		c() {
			p = element("p");
			p.textContent = "The game is built for and with the PICO-8 fantasy console, a retro Lua game engine, platform, and toolset.";
			attr(p, "slot", "content");
		},
		m(target, anchor) {
			insert(target, p, anchor);
		},
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (379:20) <Button href="https://github.com/Circl3s/circl3s-super-breakout/">
function create_default_slot_2(ctx) {
	let t;

	return {
		c() {
			t = text("View source code");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (363:16) 
function create_content_slot_2(ctx) {
	let div1;
	let p0;
	let t4;
	let p1;
	let t8;
	let div0;
	let techinfo;
	let t9;
	let button;
	let current;

	techinfo = new TechInfo({
			props: {
				bg_color: "#000000",
				text_color: "#FFF1E8",
				$$slots: {
					content: [create_content_slot_3],
					header: [create_header_slot_1]
				},
				$$scope: { ctx }
			}
		});

	button = new Button({
			props: {
				href: "https://github.com/Circl3s/circl3s-super-breakout/",
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div1 = element("div");
			p0 = element("p");

			p0.innerHTML = `Access: <code class="text-green-500">Public</code><br/>
                        Development: <code class="text-yellow-500">On-hold</code>`;

			t4 = space();
			p1 = element("p");
			p1.innerHTML = `It&#39;s a simple breakout clone I made as an easter egg for <a href="/404">this website&#39;s 404 page</a>. It&#39;s not perfect, but I think that&#39;s part of being retro.`;
			t8 = space();
			div0 = element("div");
			create_component(techinfo.$$.fragment);
			t9 = space();
			create_component(button.$$.fragment);
			attr(p0, "class", "status svelte-1apqkne");
			attr(div0, "class", "techstack svelte-1apqkne");
			attr(div1, "class", "description");
			attr(div1, "slot", "content");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, p0);
			append(div1, t4);
			append(div1, p1);
			append(div1, t8);
			append(div1, div0);
			mount_component(techinfo, div0, null);
			append(div1, t9);
			mount_component(button, div1, null);
			current = true;
		},
		p(ctx, dirty) {
			const techinfo_changes = {};

			if (dirty & /*$$scope*/ 1) {
				techinfo_changes.$$scope = { dirty, ctx };
			}

			techinfo.$set(techinfo_changes);
			const button_changes = {};

			if (dirty & /*$$scope*/ 1) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(techinfo.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(techinfo.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_component(techinfo);
			destroy_component(button);
		}
	};
}

// (386:16) 
function create_title_slot(ctx) {
	let h2;

	return {
		c() {
			h2 = element("h2");
			h2.textContent = "Helix";
			attr(h2, "slot", "title");
		},
		m(target, anchor) {
			insert(target, h2, anchor);
		},
		d(detaching) {
			if (detaching) detach(h2);
		}
	};
}

// (397:28) 
function create_header_slot(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			div.innerHTML = `<img class="logo svelte-1apqkne" src="/img/webcomponents-logo.svg" alt="WebComponents Logo"/>WEBCOMPONENTS`;
			attr(div, "class", "font-normal logotype text-lg self-center text-black svelte-1apqkne");
			attr(div, "slot", "header");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (398:28) 
function create_content_slot_1(ctx) {
	let p;

	return {
		c() {
			p = element("p");
			p.textContent = "This site is written in vanilla Javascript using the Web Components standard to harness the power of reusable components without using heavy frameworks and toolchains.";
			attr(p, "slot", "content");
		},
		m(target, anchor) {
			insert(target, p, anchor);
		},
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (403:20) <Button href="https://github.com/Circl3s/helix/">
function create_default_slot_1(ctx) {
	let t;

	return {
		c() {
			t = text("View source code");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (387:16) 
function create_content_slot(ctx) {
	let div1;
	let p0;
	let t4;
	let p1;
	let t6;
	let div0;
	let techinfo;
	let t7;
	let button;
	let current;

	techinfo = new TechInfo({
			props: {
				bg_color: "#FFFFFF",
				text_color: "#000000",
				$$slots: {
					content: [create_content_slot_1],
					header: [create_header_slot]
				},
				$$scope: { ctx }
			}
		});

	button = new Button({
			props: {
				href: "https://github.com/Circl3s/helix/",
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div1 = element("div");
			p0 = element("p");

			p0.innerHTML = `Access: <code class="text-yellow-500">Source only</code><br/>
                        Development: <code class="text-green-500">Active</code>`;

			t4 = space();
			p1 = element("p");
			p1.textContent = "Helix is a self-hosted private video platform suited to host and watch your owned TV series. Frustrated with the setup process of other self-hosted services, I opted to make Helix entirely client-side.";
			t6 = space();
			div0 = element("div");
			create_component(techinfo.$$.fragment);
			t7 = space();
			create_component(button.$$.fragment);
			attr(p0, "class", "status svelte-1apqkne");
			attr(div0, "class", "techstack svelte-1apqkne");
			attr(div1, "class", "description");
			attr(div1, "slot", "content");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, p0);
			append(div1, t4);
			append(div1, p1);
			append(div1, t6);
			append(div1, div0);
			mount_component(techinfo, div0, null);
			append(div1, t7);
			mount_component(button, div1, null);
			current = true;
		},
		p(ctx, dirty) {
			const techinfo_changes = {};

			if (dirty & /*$$scope*/ 1) {
				techinfo_changes.$$scope = { dirty, ctx };
			}

			techinfo.$set(techinfo_changes);
			const button_changes = {};

			if (dirty & /*$$scope*/ 1) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(techinfo.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(techinfo.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_component(techinfo);
			destroy_component(button);
		}
	};
}

// (148:4) <Portfolio>
function create_default_slot(ctx) {
	let div1;
	let card0;
	let t0;
	let div0;
	let t1;
	let div3;
	let card1;
	let t2;
	let div2;
	let t3;
	let div5;
	let card2;
	let t4;
	let div4;
	let t5;
	let div7;
	let card3;
	let t6;
	let div6;
	let t7;
	let div8;
	let card4;
	let t8;
	let div9;
	let card5;
	let t9;
	let div10;
	let card6;
	let current;

	card0 = new Card({
			props: {
				size: "2xl",
				$$slots: {
					content: [create_content_slot_18],
					title: [create_title_slot_6]
				},
				$$scope: { ctx }
			}
		});

	card1 = new Card({
			props: {
				size: "2xl",
				$$slots: {
					content: [create_content_slot_14],
					title: [create_title_slot_5]
				},
				$$scope: { ctx }
			}
		});

	card2 = new Card({
			props: {
				size: "2xl",
				$$slots: {
					content: [create_content_slot_11],
					title: [create_title_slot_4]
				},
				$$scope: { ctx }
			}
		});

	card3 = new Card({
			props: {
				size: "2xl",
				$$slots: {
					content: [create_content_slot_7],
					title: [create_title_slot_3]
				},
				$$scope: { ctx }
			}
		});

	card4 = new Card({
			props: {
				size: "2xl",
				$$slots: {
					content: [create_content_slot_4],
					title: [create_title_slot_2]
				},
				$$scope: { ctx }
			}
		});

	card5 = new Card({
			props: {
				size: "2xl",
				$$slots: {
					content: [create_content_slot_2],
					title: [create_title_slot_1]
				},
				$$scope: { ctx }
			}
		});

	card6 = new Card({
			props: {
				size: "2xl",
				$$slots: {
					content: [create_content_slot],
					title: [create_title_slot]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div1 = element("div");
			create_component(card0.$$.fragment);
			t0 = space();
			div0 = element("div");
			div0.innerHTML = `<img src="img/githubio.png" alt="circl3s.github.io Screenshot" class="image svelte-1apqkne"/>`;
			t1 = space();
			div3 = element("div");
			create_component(card1.$$.fragment);
			t2 = space();
			div2 = element("div");
			div2.innerHTML = `<img src="img/cybertracks_screen.png" alt="Cybertracks Screenshot" class="image svelte-1apqkne"/>`;
			t3 = space();
			div5 = element("div");
			create_component(card2.$$.fragment);
			t4 = space();
			div4 = element("div");
			div4.innerHTML = `<img src="img/Launcher.png" alt="Neko Launcher Screenshot" class="image svelte-1apqkne"/>`;
			t5 = space();
			div7 = element("div");
			create_component(card3.$$.fragment);
			t6 = space();
			div6 = element("div");
			div6.innerHTML = `<img src="https://raw.githubusercontent.com/Circl3s/vetch/master/img/vetch.png" alt="Vetch Screenshot" class="image svelte-1apqkne"/>`;
			t7 = space();
			div8 = element("div");
			create_component(card4.$$.fragment);
			t8 = space();
			div9 = element("div");
			create_component(card5.$$.fragment);
			t9 = space();
			div10 = element("div");
			create_component(card6.$$.fragment);
			attr(div0, "class", "wrapper svelte-1apqkne");
			attr(div1, "class", "row svelte-1apqkne");
			attr(div2, "class", "wrapper svelte-1apqkne");
			attr(div3, "class", "row svelte-1apqkne");
			attr(div4, "class", "wrapper svelte-1apqkne");
			attr(div5, "class", "row svelte-1apqkne");
			attr(div6, "class", "wrapper svelte-1apqkne");
			attr(div7, "class", "row svelte-1apqkne");
			attr(div8, "class", "row svelte-1apqkne");
			attr(div9, "class", "row svelte-1apqkne");
			attr(div10, "class", "row svelte-1apqkne");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			mount_component(card0, div1, null);
			append(div1, t0);
			append(div1, div0);
			insert(target, t1, anchor);
			insert(target, div3, anchor);
			mount_component(card1, div3, null);
			append(div3, t2);
			append(div3, div2);
			insert(target, t3, anchor);
			insert(target, div5, anchor);
			mount_component(card2, div5, null);
			append(div5, t4);
			append(div5, div4);
			insert(target, t5, anchor);
			insert(target, div7, anchor);
			mount_component(card3, div7, null);
			append(div7, t6);
			append(div7, div6);
			insert(target, t7, anchor);
			insert(target, div8, anchor);
			mount_component(card4, div8, null);
			insert(target, t8, anchor);
			insert(target, div9, anchor);
			mount_component(card5, div9, null);
			insert(target, t9, anchor);
			insert(target, div10, anchor);
			mount_component(card6, div10, null);
			current = true;
		},
		p(ctx, dirty) {
			const card0_changes = {};

			if (dirty & /*$$scope*/ 1) {
				card0_changes.$$scope = { dirty, ctx };
			}

			card0.$set(card0_changes);
			const card1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				card1_changes.$$scope = { dirty, ctx };
			}

			card1.$set(card1_changes);
			const card2_changes = {};

			if (dirty & /*$$scope*/ 1) {
				card2_changes.$$scope = { dirty, ctx };
			}

			card2.$set(card2_changes);
			const card3_changes = {};

			if (dirty & /*$$scope*/ 1) {
				card3_changes.$$scope = { dirty, ctx };
			}

			card3.$set(card3_changes);
			const card4_changes = {};

			if (dirty & /*$$scope*/ 1) {
				card4_changes.$$scope = { dirty, ctx };
			}

			card4.$set(card4_changes);
			const card5_changes = {};

			if (dirty & /*$$scope*/ 1) {
				card5_changes.$$scope = { dirty, ctx };
			}

			card5.$set(card5_changes);
			const card6_changes = {};

			if (dirty & /*$$scope*/ 1) {
				card6_changes.$$scope = { dirty, ctx };
			}

			card6.$set(card6_changes);
		},
		i(local) {
			if (current) return;
			transition_in(card0.$$.fragment, local);
			transition_in(card1.$$.fragment, local);
			transition_in(card2.$$.fragment, local);
			transition_in(card3.$$.fragment, local);
			transition_in(card4.$$.fragment, local);
			transition_in(card5.$$.fragment, local);
			transition_in(card6.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(card0.$$.fragment, local);
			transition_out(card1.$$.fragment, local);
			transition_out(card2.$$.fragment, local);
			transition_out(card3.$$.fragment, local);
			transition_out(card4.$$.fragment, local);
			transition_out(card5.$$.fragment, local);
			transition_out(card6.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_component(card0);
			if (detaching) detach(t1);
			if (detaching) detach(div3);
			destroy_component(card1);
			if (detaching) detach(t3);
			if (detaching) detach(div5);
			destroy_component(card2);
			if (detaching) detach(t5);
			if (detaching) detach(div7);
			destroy_component(card3);
			if (detaching) detach(t7);
			if (detaching) detach(div8);
			destroy_component(card4);
			if (detaching) detach(t8);
			if (detaching) detach(div9);
			destroy_component(card5);
			if (detaching) detach(t9);
			if (detaching) detach(div10);
			destroy_component(card6);
		}
	};
}

function create_fragment(ctx) {
	let div;
	let navbar;
	let t0;
	let section;
	let t1;
	let portfolio;
	let t2;
	let footer;
	let current;

	navbar = new Navbar({
			props: {
				subtitle: "Programming",
				always_visible: true
			}
		});

	section = new Section({
			props: {
				$$slots: { default: [create_default_slot_11] },
				$$scope: { ctx }
			}
		});

	portfolio = new Portfolio({
			props: {
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	footer = new Footer({});

	return {
		c() {
			div = element("div");
			create_component(navbar.$$.fragment);
			t0 = space();
			create_component(section.$$.fragment);
			t1 = space();
			create_component(portfolio.$$.fragment);
			t2 = space();
			create_component(footer.$$.fragment);
			attr(div, "class", "Programming");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(navbar, div, null);
			append(div, t0);
			mount_component(section, div, null);
			append(div, t1);
			mount_component(portfolio, div, null);
			append(div, t2);
			mount_component(footer, div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			const section_changes = {};

			if (dirty & /*$$scope*/ 1) {
				section_changes.$$scope = { dirty, ctx };
			}

			section.$set(section_changes);
			const portfolio_changes = {};

			if (dirty & /*$$scope*/ 1) {
				portfolio_changes.$$scope = { dirty, ctx };
			}

			portfolio.$set(portfolio_changes);
		},
		i(local) {
			if (current) return;
			transition_in(navbar.$$.fragment, local);
			transition_in(section.$$.fragment, local);
			transition_in(portfolio.$$.fragment, local);
			transition_in(footer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(navbar.$$.fragment, local);
			transition_out(section.$$.fragment, local);
			transition_out(portfolio.$$.fragment, local);
			transition_out(footer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(navbar);
			destroy_component(section);
			destroy_component(portfolio);
			destroy_component(footer);
		}
	};
}

class Programming extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, null, create_fragment, safe_not_equal, {});
	}
}

export default Programming;