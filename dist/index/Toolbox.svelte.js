import './Toolbox.svelte.css.proxy.js';
/* src/index/Toolbox.svelte generated by Svelte v3.38.3 */
import {
	SvelteComponent,
	add_render_callback,
	append,
	attr,
	create_component,
	destroy_component,
	detach,
	element,
	init,
	insert,
	listen,
	mount_component,
	safe_not_equal,
	set_style,
	space,
	text,
	transition_in,
	transition_out
} from "../../_snowpack/pkg/svelte/internal.js";

import Button from "../shared/Button.svelte.js";
import Card from "../shared/Card.svelte.js";
import JSWASMLogo from "../shared/JSWASMLogo.svelte.js";
import Marker from "../shared/Marker.svelte.js";

function create_title_slot(ctx) {
	let h1;

	return {
		c() {
			h1 = element("h1");
			h1.textContent = "Circl3s' Toolbox";
			attr(h1, "slot", "title");
		},
		m(target, anchor) {
			insert(target, h1, anchor);
		},
		d(detaching) {
			if (detaching) detach(h1);
		}
	};
}

// (35:12) <Button disabled>
function create_default_slot(ctx) {
	let t;

	return {
		c() {
			t = text("Coming soon");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (33:8) 
function create_content_slot(ctx) {
	let div;
	let p;
	let t1;
	let button;
	let current;

	button = new Button({
			props: {
				disabled: true,
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div = element("div");
			p = element("p");
			p.textContent = "A collection of common web-based tools hosted on my own site for security and ease of access. Implemented using JavaScript and WebAssembly.";
			t1 = space();
			create_component(button.$$.fragment);
			attr(div, "slot", "content");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, p);
			append(div, t1);
			mount_component(button, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 4) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(button);
		}
	};
}

function create_fragment(ctx) {
	let scrolling = false;

	let clear_scrolling = () => {
		scrolling = false;
	};

	let scrolling_timeout;
	let marker;
	let t0;
	let div;
	let jswasmlogo;
	let t1;
	let card;
	let current;
	let mounted;
	let dispose;
	add_render_callback(/*onwindowscroll*/ ctx[1]);
	marker = new Marker({ props: { name: "toolbox" } });
	jswasmlogo = new JSWASMLogo({});

	card = new Card({
			props: {
				$$slots: {
					content: [create_content_slot],
					title: [create_title_slot]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(marker.$$.fragment);
			t0 = space();
			div = element("div");
			create_component(jswasmlogo.$$.fragment);
			t1 = space();
			create_component(card.$$.fragment);
			attr(div, "class", "Toolbox svelte-1go2lab");
			set_style(div, "background-position-y", /*scroll*/ ctx[0] / 3 + "px");
		},
		m(target, anchor) {
			mount_component(marker, target, anchor);
			insert(target, t0, anchor);
			insert(target, div, anchor);
			mount_component(jswasmlogo, div, null);
			append(div, t1);
			mount_component(card, div, null);
			current = true;

			if (!mounted) {
				dispose = listen(window, "scroll", () => {
					scrolling = true;
					clearTimeout(scrolling_timeout);
					scrolling_timeout = setTimeout(clear_scrolling, 100);
					/*onwindowscroll*/ ctx[1]();
				});

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*scroll*/ 1 && !scrolling) {
				scrolling = true;
				clearTimeout(scrolling_timeout);
				scrollTo(window.pageXOffset, /*scroll*/ ctx[0]);
				scrolling_timeout = setTimeout(clear_scrolling, 100);
			}

			const card_changes = {};

			if (dirty & /*$$scope*/ 4) {
				card_changes.$$scope = { dirty, ctx };
			}

			card.$set(card_changes);

			if (!current || dirty & /*scroll*/ 1) {
				set_style(div, "background-position-y", /*scroll*/ ctx[0] / 3 + "px");
			}
		},
		i(local) {
			if (current) return;
			transition_in(marker.$$.fragment, local);
			transition_in(jswasmlogo.$$.fragment, local);
			transition_in(card.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(marker.$$.fragment, local);
			transition_out(jswasmlogo.$$.fragment, local);
			transition_out(card.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(marker, detaching);
			if (detaching) detach(t0);
			if (detaching) detach(div);
			destroy_component(jswasmlogo);
			destroy_component(card);
			mounted = false;
			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let scroll;

	function onwindowscroll() {
		$$invalidate(0, scroll = window.pageYOffset)
	}

	return [scroll, onwindowscroll];
}

class Toolbox extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default Toolbox;